{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Basics","text":"<p>neat_state is a lightweight, feature-rich state management package for Flutter that builds upon <code>ValueNotifier</code> to provide a robust solution for handling states, one-time actions, and asynchronous operations with built-in loading and error management.</p>"},{"location":"#why-neat_state","title":"Why neat_state?","text":"<ul> <li>Simple Usage: The API is straightforward\u2014you don't need to memorize a complex vocabulary of class names.</li> <li>Non-intrusive: It respects standard Flutter architecture. You don't need to extend your Widgets or States with special base classes.</li> <li>Familiar API: If you know <code>ValueNotifier</code>, you know <code>neat_state</code>.</li> <li>Built-in Async: Native support for loading states and error handling.</li> <li>One-time Actions: Perfect for snackbars, navigation, or dialogs.</li> <li>Granular Rebuilds: Optimized with <code>InheritedModel</code> and <code>context.select</code>.</li> </ul>"},{"location":"#example","title":"Example","text":"<p>Here is a simple counter example:</p> <pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nvoid main() {\n  runApp(const MaterialApp(home: SimpleExamplePage()));\n}\n\n// 1. Create a notifier\nclass CounterNotifier extends NeatNotifier&lt;int, void&gt; {\n  CounterNotifier() : super(0);\n\n  void increment() =&gt; value++;\n}\n\nclass SimpleExamplePage extends StatelessWidget {\n  const SimpleExamplePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 2. Use it in your UI\n    return NeatState&lt;CounterNotifier, int, void&gt;(\n      create: (_) =&gt; CounterNotifier(),\n      builder: (context, count, _) {\n        return Scaffold(\n          appBar: AppBar(title: const Text('Simple Example')),\n          body: Center(\n            child: Text(\n              'Count: $count',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ),\n          floatingActionButton: FloatingActionButton(\n            onPressed: () =&gt; context.read&lt;CounterNotifier&gt;().increment(),\n            child: const Icon(Icons.add),\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Add <code>neat_state</code> to your <code>pubspec.yaml</code>:</p> <pre><code>dependencies:\n  neat_state: ^2.0.0\n</code></pre> <p>Or run:</p> <pre><code>flutter pub add neat_state\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Async Operations</li> <li>Reading State efficiently</li> <li>Side Effects &amp; Listeners</li> <li>Persisting State</li> <li>Undo/Redo</li> <li>Multiple Providers</li> <li>Advanced Usage</li> </ul>"},{"location":"02_async/","title":"Async Operations","text":"<p><code>NeatNotifier</code> simplifies asynchronous operations with the <code>runTask</code> method. It automatically handles loading states and error capturing, allowing you to focus on your business logic.</p>"},{"location":"02_async/#using-runtask","title":"Using <code>runTask</code>","text":"<p>Wrap your async logic inside <code>runTask</code>. It will: 1. Set <code>isLoading</code> to <code>true</code>. 2. Clear any previous errors. 3. Execute your specific task. 4. Set <code>isLoading</code> to <code>false</code> when finished. 5. Capture any exceptions into the <code>error</code> property.</p> <pre><code>class UserNotifier extends NeatNotifier&lt;String?, void&gt; {\n  UserNotifier() : super(null);\n\n  Future&lt;void&gt; fetchUser() async {\n    // runTask automatically handles isLoading and error records.\n    await runTask(() async {\n      // Simulate network delay\n      await Future.delayed(const Duration(seconds: 2));\n\n      // Update value on success\n      value = 'John Doe';\n    });\n  }\n}\n</code></pre>"},{"location":"02_async/#ui-handling","title":"UI Handling","text":"<p><code>NeatState</code> provides built-in builders for loading and error states, making it easy to show the appropriate UI.</p> <pre><code>NeatState&lt;UserNotifier, String?, void&gt;(\n  create: (_) =&gt; UserNotifier(),\n\n  // Custom loading UI\n  loadingBuilder: (context, loading, child) {\n    return const Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          CircularProgressIndicator(),\n          SizedBox(height: 16),\n          Text('Loading user...'),\n        ],\n      ),\n    );\n  },\n\n  // Custom error UI\n  errorBuilder: (context, error, child) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.error_outline, color: Colors.red, size: 64),\n          SizedBox(height: 16),\n          Text('Error: ${error.error}'),\n          SizedBox(height: 24),\n          ElevatedButton(\n            onPressed: () =&gt; context.read&lt;UserNotifier&gt;().fetchUser(),\n            child: const Text('Retry'),\n          ),\n        ],\n      ),\n    );\n  },\n\n  // Success UI\n  builder: (context, user, child) {\n    return Center(\n      child: Text(\n        user != null ? 'Welcome, $user!' : 'No user data.',\n        style: const TextStyle(fontSize: 24),\n      ),\n    );\n  },\n)\n</code></pre>"},{"location":"02_async/#accessing-loading-state-directly","title":"Accessing Loading State directly","text":"<p>You can also access the loading state manually if you are not using <code>NeatState</code> or want to use it in a different way (e.g. disabling a button).</p> <pre><code>final isLoading = context.select&lt;UserNotifier, String?, bool&gt;(\n  (state) =&gt; context.read&lt;UserNotifier&gt;().isLoading\n);\n</code></pre>"},{"location":"02_async/#example","title":"Example","text":"<pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\n/// A notifier that simulates fetching a user name from a network.\nclass UserNotifier extends NeatNotifier&lt;String?, void&gt; {\n  UserNotifier() : super(null);\n\n  /// Fetches a user name asynchronously using [runTask].\n  Future&lt;void&gt; fetchUser({bool simulateError = false}) async {\n    // runTask automatically handles isLoading and error records.\n    await runTask(() async {\n      // Simulate network delay\n      await Future.delayed(const Duration(seconds: 2));\n\n      if (simulateError) {\n        throw Exception('Failed to connect to the server');\n      }\n\n      // Manually update the value upon success.\n      value = 'John Doe';\n    });\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(useMaterial3: true, primarySwatch: Colors.blue),\n      home: NeatState&lt;UserNotifier, String?, void&gt;(\n        create: (_) =&gt; UserNotifier(),\n        loadingBuilder: (context, loading, child) =&gt; const Scaffold(\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                CircularProgressIndicator(),\n                SizedBox(height: 16),\n                const Text('Loading user...'),\n              ],\n            ),\n          ),\n        ),\n        errorBuilder: (context, error, child) =&gt; Scaffold(\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                const Icon(Icons.error_outline, color: Colors.red, size: 64),\n                const SizedBox(height: 16),\n                Text('Error: ${error.error}'),\n                const SizedBox(height: 24),\n                Builder(\n                  builder: (context) =&gt; ElevatedButton(\n                    onPressed: () =&gt; context.read&lt;UserNotifier&gt;().fetchUser(),\n                    child: const Text('Retry'),\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ),\n        builder: (context, user, child) {\n          return Scaffold(\n            appBar: AppBar(title: const Text('NeatNotifier: runTask')),\n            body: Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: [\n                  Text(\n                    user != null ? 'Welcome, $user!' : 'No user data.',\n                    style: const TextStyle(fontSize: 24),\n                  ),\n                  const SizedBox(height: 32),\n                  Row(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: [\n                      ElevatedButton(\n                        onPressed: () =&gt;\n                            context.read&lt;UserNotifier&gt;().fetchUser(),\n                        child: const Text('Fetch Success'),\n                      ),\n                      const SizedBox(width: 16),\n                      ElevatedButton(\n                        onPressed: () =&gt; context.read&lt;UserNotifier&gt;().fetchUser(\n                          simulateError: true,\n                        ),\n                        style: ElevatedButton.styleFrom(\n                          foregroundColor: Colors.red,\n                        ),\n                        child: const Text('Fetch Error'),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"02_async/#next-steps","title":"Next Steps","text":"<ul> <li>Reading State efficiently</li> </ul>"},{"location":"03_reading_state/","title":"Reading State","text":"<p><code>neat_state</code> provides a set of powerful extensions on <code>BuildContext</code> to interact with your notifiers. These extensions make it easy to access state, listen for changes, and select specific parts of the state to optimize rebuilds.</p>"},{"location":"03_reading_state/#contextreadt","title":"<code>context.read&lt;T&gt;</code>","text":"<p>Obtains the notifier of type <code>T</code> from the nearest ancestor <code>NeatState</code> or <code>NeatMultiState</code>.</p> <ul> <li>Usage: Use this when you need to call a method on the notifier (like an event handler) or access its value without triggering a rebuild.</li> <li>Common Use Case: <code>onPressed</code> callbacks, <code>initState</code> logic.</li> </ul> <pre><code>ElevatedButton(\n  // Does not rebuild when CounterNotifier changes\n  onPressed: () =&gt; context.read&lt;CounterNotifier&gt;().increment(),\n  child: const Text('Increment'),\n),\n</code></pre>"},{"location":"03_reading_state/#contextwatcht","title":"<code>context.watch&lt;T&gt;</code>","text":"<p>Obtains the notifier of type <code>T</code> and subscribes the widget to changes.</p> <ul> <li>Usage: Use this when your widget needs to rebuild every time the notifier's value changes.</li> <li>Common Use Case: Building UI that depends on the entire state.</li> </ul> <pre><code>@override\nWidget build(BuildContext context) {\n  // Rebuilds whenever ThemeNotifier changes\n  final themeMode = context.watch&lt;ThemeNotifier&gt;().value;\n\n  return MaterialApp(\n    themeMode: themeMode,\n    // ...\n  );\n}\n</code></pre>"},{"location":"03_reading_state/#contextselectt-r","title":"<code>context.select&lt;T, R&gt;</code>","text":"<p>Listens to a specific part of the state.</p> <ul> <li>Usage: Use this to optimize performance by only rebuilding when a specific property of the state changes.</li> <li>Parameters: </li> <li><code>T</code>: The type of the Notifier.</li> <li><code>R</code>: The type of the selected value.</li> <li><code>selector</code>: A function that maps the state (or notifier) to the value you want to listen to.</li> </ul> <pre><code>@override\nWidget build(BuildContext context) {\n  // Only rebuild if the user's name changes, ignore age or other property changes\n  final name = context.select&lt;UserNotifier, User, String&gt;((user) =&gt; user.name);\n\n  return Text('Name: $name');\n}\n</code></pre> <p>:::tip <code>context.select</code> is powered by <code>InheritedModel</code>, ensuring efficient updates only when necessary. :::</p>"},{"location":"03_reading_state/#example","title":"Example","text":"<pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\n// --- Simple Notifier ---\nclass CounterNotifier extends NeatNotifier&lt;int, void&gt; {\n  CounterNotifier() : super(0);\n\n  void increment() =&gt; value++;\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return NeatState&lt;CounterNotifier, int, void&gt;(\n      create: (_) =&gt; CounterNotifier(),\n      child: const MaterialApp(\n        debugShowCheckedModeBanner: false,\n        home: HomePage(),\n      ),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. context.watch: Rebuilds whenever state changes\n    final count = context.watch&lt;CounterNotifier&gt;().value;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Context Extensions')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            const Text(\n              'Context.watch:',\n              style: TextStyle(fontWeight: FontWeight.bold),\n            ),\n            Text('$count', style: const TextStyle(fontSize: 40)),\n            const SizedBox(height: 32),\n            const SelectorExample(),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        // 2. context.read: Access notifier without rebuilding\n        onPressed: () =&gt; context.read&lt;CounterNotifier&gt;().increment(),\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n\nclass SelectorExample extends StatelessWidget {\n  const SelectorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 3. context.select: Only rebuilds when the selected value changes\n    final isGreaterThanFive = context.select&lt;CounterNotifier, int, bool&gt;(\n      (count) =&gt; count &gt; 5,\n    );\n\n    return Container(\n      padding: const EdgeInsets.all(16),\n      color: isGreaterThanFive ? Colors.green.shade100 : Colors.grey.shade200,\n      child: Text(\n        isGreaterThanFive ? '&gt; 5' : '&lt;= 5',\n        style: const TextStyle(fontSize: 24),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"03_reading_state/#next-steps","title":"Next Steps","text":"<ul> <li>Side Effects &amp; Listeners</li> </ul>"},{"location":"04_listeners/","title":"Side Effects &amp; Listeners","text":"<p>State management isn't just about rebuilding UI. Sometimes you need to perform actions once when a state changes, such as showing a Snackbar, navigating to a new screen, or displaying a dialog.</p> <p><code>neat_state</code> handles this elegantly via the <code>listener</code> callback in the <code>NeatState</code> widget.</p>"},{"location":"04_listeners/#the-listener-callback","title":"The <code>listener</code> Callback","text":"<p>The <code>NeatState</code> widget provides a <code>listener</code> parameter that is called whenever the notifier emits a new value. This callback is run after the build phase, making it safe to trigger side effects like navigation or showing overlays.</p>"},{"location":"04_listeners/#api-breakdown","title":"API Breakdown","text":"<pre><code>NeatState&lt;MyNotifier, StateType, EventType&gt;(\n  create: (_) =&gt; MyNotifier(),\n  listener: (context, state) {\n    // Check state and trigger side effects\n  },\n  builder: (context, state, child) {\n    return MyWidget();\n  },\n)\n</code></pre>"},{"location":"04_listeners/#common-use-cases","title":"Common Use Cases","text":""},{"location":"04_listeners/#1-showing-a-snackbar-on-error","title":"1. Showing a Snackbar on Error","text":"<p>You can listen for specific state conditions to show feedback to the user.</p> <pre><code>listener: (context, state) {\n  if (state == MyState.error) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      const SnackBar(content: Text('Something went wrong!')),\n    );\n  }\n},\n</code></pre>"},{"location":"04_listeners/#2-navigation-on-success","title":"2. Navigation on Success","text":"<p>Navigate to a different screen when an operation completes successfully.</p> <pre><code>listener: (context, state) {\n  if (state == MyState.success) {\n    Navigator.of(context).pushReplacementNamed('/dashboard');\n  }\n},\n</code></pre>"},{"location":"04_listeners/#3-displaying-dialogs","title":"3. Displaying Dialogs","text":"<p>Show a dialog when a specific event occurs.</p> <pre><code>listener: (context, state) {\n  if (state.requiresConfirmation) {\n    showDialog(\n      context: context,\n      builder: (_) =&gt; AlertDialog(\n        title: Text('Confirm'),\n        content: Text('Are you sure?'),\n      ),\n    );\n  }\n},\n</code></pre>"},{"location":"04_listeners/#best-practices","title":"Best Practices","text":"<ul> <li>Keep it Logic-Free: Try to keep business logic inside your Notifier. Use the listener primarily for UI-related side effects.</li> <li>Context Usage: The <code>listener</code> callback provides a valid <code>BuildContext</code>, so you don't need to look it up manually.</li> </ul>"},{"location":"04_listeners/#next-steps","title":"Next Steps","text":"<ul> <li>Persisting State </li> </ul>"},{"location":"05_persistence/","title":"Persisting State","text":"<p><code>NeatHydratedNotifier</code> adds automatic persistence to your notifiers. It saves the state to disk whenever it changes and restores it when the notifier is initialized.</p>"},{"location":"05_persistence/#usage","title":"Usage","text":"<ol> <li>Initialize Storage: Call <code>NeatHydratedStorage.initialize()</code> before <code>runApp</code>.</li> <li>Mix in <code>NeatHydratedNotifier</code>: Add the mixin to your notifier.</li> <li>Implement <code>id</code>, <code>fromJson</code>, and <code>toJson</code>: These are required for identification and serialization.</li> <li>Call <code>hydrate()</code>: Call this in the constructor to load the saved state.</li> </ol> <pre><code>class SettingsNotifier extends NeatNotifier&lt;ThemeMode, void&gt; with NeatHydratedNotifier&lt;ThemeMode, void&gt; {\n  SettingsNotifier() : super(ThemeMode.system) {\n    hydrate();\n  }\n\n  @override\n  String get id =&gt; 'settings_persistence';\n\n  @override\n  ThemeMode? fromJson(Map&lt;String, dynamic&gt; json) =&gt; ThemeMode.values[json['theme'] as int];\n\n  @override\n  Map&lt;String, dynamic&gt; toJson(ThemeMode state) =&gt; {'theme': state.index};\n}\n</code></pre>"},{"location":"05_persistence/#example","title":"Example","text":"<pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nclass SettingsNotifier extends NeatNotifier&lt;ThemeMode, void&gt;\n    with NeatHydratedNotifier&lt;ThemeMode, void&gt; {\n  SettingsNotifier() : super(ThemeMode.system) {\n    hydrate();\n  }\n  @override\n  String get id =&gt; 'settings';\n  void toggle() =&gt;\n      value = value == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n  @override\n  ThemeMode? fromJson(Map&lt;String, dynamic&gt; json) =&gt;\n      ThemeMode.values[json['theme'] as int];\n  @override\n  Map&lt;String, dynamic&gt; toJson(ThemeMode state) =&gt; {'theme': state.index};\n}\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await NeatHydratedStorage.initialize(); // Uses default Hive storage\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return NeatState(\n      create: (_) =&gt; SettingsNotifier(),\n      builder: (context, mode, _) {\n        return MaterialApp(\n          themeMode: mode,\n          theme: ThemeData.light(),\n          darkTheme: ThemeData.dark(),\n          home: Scaffold(\n            appBar: AppBar(title: const Text('Hydrated State Demo')),\n            body: Center(child: Text('Current Mode: $mode')),\n            floatingActionButton: FloatingActionButton(\n              onPressed: () =&gt; context.read&lt;SettingsNotifier&gt;().toggle(),\n              child: const Icon(Icons.brightness_4),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n</code></pre> <p>:::tip In a real application, you would use a persistent storage like <code>shared_preferences</code> or <code>hive</code>. See the Advanced Patterns folder for a storage implementation using <code>path_provider</code>. :::</p>"},{"location":"05_persistence/#next-steps","title":"Next Steps","text":"<ul> <li>Undo/Redo</li> </ul>"},{"location":"06_undo_redo/","title":"Undo/Redo","text":"<p><code>NeatUndoRedoNotifier</code> provides a simple way to add history support to your state. It maintains a history stack and a redo stack, allowing you to move backwards and forwards through state changes.</p>"},{"location":"06_undo_redo/#usage","title":"Usage","text":"<ol> <li>Mix in <code>NeatUndoRedoNotifier</code>: Add the mixin to your notifier.</li> <li>Call <code>setupUndoRedo()</code>: Initialize history in the constructor.</li> <li>Use <code>undo()</code> and <code>redo()</code>: Trigger transitions as needed.</li> <li>Check <code>canUndo</code> and <code>canRedo</code>: Useful for enabling/disabling UI buttons.</li> </ol> <pre><code>class DrawingNotifier extends NeatNotifier&lt;List&lt;Offset&gt;, void&gt; with NeatUndoRedoNotifier&lt;List&lt;Offset&gt;, void&gt; {\n  DrawingNotifier() : super([]) {\n    setupUndoRedo(maxHistory: 50);\n  }\n\n  void addPoint(Offset point) {\n    value = List.from(value)..add(point);\n  }\n}\n</code></pre>"},{"location":"06_undo_redo/#example","title":"Example","text":"<pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nclass DrawingNotifier extends NeatNotifier&lt;List&lt;Offset&gt;, void&gt;\n    with NeatUndoRedoNotifier&lt;List&lt;Offset&gt;, void&gt; {\n  DrawingNotifier() : super([]) {\n    setupUndoRedo();\n  }\n  void addPoint(Offset point) =&gt; value = List.from(value)..add(point);\n  void clear() =&gt; value = [];\n}\n\nvoid main() =&gt; runApp(const MaterialApp(home: UndoRedoDemo()));\n\nclass UndoRedoDemo extends StatelessWidget {\n  const UndoRedoDemo({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return NeatState(\n      create: (_) =&gt; DrawingNotifier(),\n      builder: (context, points, _) {\n        final notifier = context.read&lt;DrawingNotifier&gt;();\n        return Scaffold(\n          appBar: AppBar(\n            title: const Text('Undo/Redo Canvas'),\n            actions: [\n              IconButton(\n                icon: const Icon(Icons.undo),\n                onPressed: notifier.canUndo ? notifier.undo : null,\n              ),\n              IconButton(\n                icon: const Icon(Icons.redo),\n                onPressed: notifier.canRedo ? notifier.redo : null,\n              ),\n              IconButton(\n                icon: const Icon(Icons.delete),\n                onPressed: notifier.clear,\n              ),\n            ],\n          ),\n          body: GestureDetector(\n            onPanUpdate: (details) =&gt; notifier.addPoint(details.localPosition),\n            child: CustomPaint(\n              painter: SimplePainter(points),\n              size: Size.infinite,\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass SimplePainter extends CustomPainter {\n  final List&lt;Offset&gt; points;\n  SimplePainter(this.points);\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = Colors.blue\n      ..strokeWidth = 4.0\n      ..strokeCap = StrokeCap.round;\n    for (int i = 0; i &lt; points.length - 1; i++) {\n      canvas.drawLine(points[i], points[i + 1], paint);\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;\n}\n</code></pre>"},{"location":"06_undo_redo/#next-steps","title":"Next Steps","text":"<ul> <li>Multiple Providers</li> </ul>"},{"location":"07_multi_providers/","title":"Multiple Providers","text":"<p>For applications with multiple notifiers, <code>NeatMultiState</code> helps you inject dependencies high up in the widget tree, making them accessible to all descendants.</p>"},{"location":"07_multi_providers/#neatmultistate","title":"<code>NeatMultiState</code>","text":"<p>This widget avoids the \"pyramid of doom\" (nested builders) when you have multiple providers. It supports both independent notifiers and dependent \"providers\" (like <code>NeatState</code> widgets).</p>"},{"location":"07_multi_providers/#usage","title":"Usage","text":"<pre><code>NeatMultiState(\n  // 1. Independent Notifiers\n  // Notifiers that don't depend on others.\n  independent: [\n    (_) =&gt; CounterNotifier(),\n    (_) =&gt; ThemeNotifier(),\n  ],\n\n  // 2. Dependent Providers\n  // Function builders that can nest other providers or depend on independent ones.\n  // These are built in order, so later items can depend on earlier ones.\n  providers: [\n    (child) =&gt; NeatState&lt;UserNotifier, User, void&gt;(\n          create: (_) =&gt; UserNotifier(),\n          builder: (context, user, _) =&gt; child,\n        ),\n    (child) =&gt; ProxyProvider0&lt;AuthService&gt;( // Example of interop\n          update: (_, __) =&gt; AuthService(),\n          child: child,\n        ),\n  ],\n\n  child: MyApp(),\n)\n</code></pre>"},{"location":"07_multi_providers/#accessing-state","title":"Accessing State","text":"<p>To access the state efficiently, use the provided context extensions.  See the Reading State page for detailed usage of <code>context.read</code>, <code>context.watch</code>, and <code>context.select</code>.</p>"},{"location":"07_multi_providers/#example","title":"Example","text":"<pre><code>import 'package:flutter/material.dart';\nimport 'package:neat_state/neat_state.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\n// --- Notifiers ---\n\nclass ThemeNotifier extends NeatNotifier&lt;ThemeMode, void&gt; {\n  ThemeNotifier() : super(ThemeMode.light);\n\n  void toggleTheme() {\n    value = value == ThemeMode.light ? ThemeMode.dark : ThemeMode.light;\n  }\n}\n\nclass CounterNotifier extends NeatNotifier&lt;int, String&gt; {\n  CounterNotifier() : super(0);\n\n  void increment() {\n    value++;\n    if (value % 5 == 0) {\n      sendAction('Reached $value!');\n    }\n  }\n}\n\nclass UserNotifier extends NeatNotifier&lt;User, void&gt; {\n  UserNotifier() : super(User(name: 'Guest', age: 25));\n\n  void updateName(String name) {\n    value = value.copyWith(name: name);\n  }\n\n  void incrementAge() {\n    value = value.copyWith(age: value.age + 1);\n  }\n}\n\nclass User {\n  final String name;\n  final int age;\n\n  User({required this.name, required this.age});\n\n  User copyWith({String? name, int? age}) {\n    return User(name: name ?? this.name, age: age ?? this.age);\n  }\n}\n\n// --- App ---\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return NeatMultiState(\n      independent: [\n        (_) =&gt; CounterNotifier(),\n        (_) =&gt; UserNotifier(),\n        (_) =&gt; ThemeNotifier(),\n      ],\n      child: Builder(\n        builder: (context) {\n          final themeMode = context.watch&lt;ThemeNotifier&gt;().value;\n          return MaterialApp(\n            title: 'Neat Multi-State Example',\n            debugShowCheckedModeBanner: false,\n            themeMode: themeMode,\n            theme: ThemeData(useMaterial3: true),\n            darkTheme: ThemeData.dark(useMaterial3: true),\n            home: const MyHomePage(),\n          );\n        },\n      ),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Neat Multi-State'),\n        actions: [\n          IconButton(\n            icon: context.watch&lt;ThemeNotifier&gt;().value == ThemeMode.light\n                ? const Icon(Icons.dark_mode)\n                : const Icon(Icons.light_mode),\n            onPressed: () =&gt; context.read&lt;ThemeNotifier&gt;().toggleTheme(),\n          ),\n        ],\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            const CounterCard(),\n            const SizedBox(height: 16),\n            const UserCard(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass CounterCard extends StatelessWidget {\n  const CounterCard({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return NeatState&lt;CounterNotifier, int, String&gt;(\n      onAction: (context, action) {\n        ScaffoldMessenger.of(\n          context,\n        ).showSnackBar(SnackBar(content: Text(action)));\n      },\n      builder: (context, count, _) {\n        return Card(\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Column(\n              children: [\n                const Text('Counter Notifier', style: TextStyle(fontSize: 20)),\n                const SizedBox(height: 8),\n                Text('Count: $count', style: const TextStyle(fontSize: 32)),\n                ElevatedButton(\n                  onPressed: () =&gt; context.read&lt;CounterNotifier&gt;().increment(),\n                  child: const Text('Increment'),\n                ),\n              ],\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass UserCard extends StatelessWidget {\n  const UserCard({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final name = context.select&lt;UserNotifier, User, String&gt;((u) =&gt; u.name);\n    final age = context.select&lt;UserNotifier, User, int&gt;((u) =&gt; u.age);\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            const Text('User Notifier', style: TextStyle(fontSize: 20)),\n            const SizedBox(height: 8),\n            Text('Name: $name', style: const TextStyle(fontSize: 18)),\n            Text('Age: $age', style: const TextStyle(fontSize: 18)),\n            const SizedBox(height: 16),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                ElevatedButton(\n                  onPressed: () =&gt; context.read&lt;UserNotifier&gt;().updateName(\n                    'User ${DateTime.now().second}',\n                  ),\n                  child: const Text('Update Name'),\n                ),\n                const SizedBox(width: 8),\n                ElevatedButton(\n                  onPressed: () =&gt; context.read&lt;UserNotifier&gt;().incrementAge(),\n                  child: const Text('Increment Age'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"07_multi_providers/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage</li> </ul>"},{"location":"08_advanced/","title":"Advanced Usage","text":"<p>This page covers advanced features of <code>neat_state</code> for global observability and action interception.</p>"},{"location":"08_advanced/#neatobserver","title":"NeatObserver","text":"<p><code>NeatObserver</code> allows you to listen to events across all <code>NeatNotifier</code> instances in your app. This is useful for logging, analytics, or debugging.</p> <p>To use it, implement the <code>NeatObserver</code> interface and assign it to <code>NeatNotifier.observer</code>.</p> <pre><code>class MyLogger extends NeatObserver {\n  @override\n  void onAction(NeatNotifier notifier, dynamic action) {\n    print('[Action] ${notifier.runtimeType}: $action');\n  }\n\n  @override\n  void onStateChange(NeatNotifier notifier, dynamic state) {\n    print('[State] ${notifier.runtimeType}: $state');\n  }\n\n  @override\n  void onError(NeatNotifier notifier, Object error, StackTrace? stackTrace) {\n    print('[Error] ${notifier.runtimeType}: $error');\n  }\n}\n\nvoid main() {\n  NeatNotifier.observer = MyLogger();\n  runApp(MyApp());\n}\n</code></pre>"},{"location":"08_advanced/#interceptors","title":"Interceptors","text":"<p>Interceptors allow you to inspect, transform, or block actions before they are emitted to listeners.</p> <p>Each <code>NeatNotifier</code> has an <code>interceptors</code> list. You can add functions to this list. - Return the action (modified or original) to pass it to the next interceptor. - Return <code>null</code> to block the action.</p> <pre><code>class AuthNotifier extends NeatNotifier&lt;AuthState, AuthAction&gt; {\n  AuthNotifier() : super(AuthState.initial()) {\n    // Add an interceptor\n    interceptors.add((action) {\n      if (action is NavigateHome &amp;&amp; !value.isAuthenticated) {\n        // Block navigation if not authenticated\n        return null; \n      }\n      return action;\n    });\n  }\n}\n</code></pre>"}]}